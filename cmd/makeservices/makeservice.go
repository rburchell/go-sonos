package main

import (
	"bytes"
	"encoding/xml"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

type AllowedValueRange struct {
	XMLName xml.Name `xml:"allowedValueRange"`
	Minimum string   `xml:"minimum"`
	Maximum string   `xml:"maximum"`
	Step    string   `xml:"step"`
}

type StateVariable struct {
	XMLName           xml.Name           `xml:"stateVariable"`
	SendEvents        string             `xml:"sendEvents,attr"`
	Multicast         string             `xml:"multicast,attr"`
	Name              string             `xml:"name"`
	DataType          string             `xml:"dataType"`
	DefaultValue      string             `xml:"defaultValue"`
	AllowedValueRange *AllowedValueRange `xml:"allowedValueRange"`
	AllowedValues     []string           `xml:"allowedValueList>allowedValue"`
}

func (s *StateVariable) GoDataType() string {
	switch s.DataType {
	case "ui1":
		return "uint8"
	case "ui2":
		return "uint16"
	case "ui4":
		return "uint32"
	case "i1":
		return "int8"
	case "i2":
		return "int16"
	case "i4":
		return "int32"
	case "int":
		return "int64"
	case "r4":
		return "flaot32"
	case "number", "r8":
		return "float"
	case "float", "float64":
		return "float"
	// case "fixed.14.4": // TODO fixed
	case "char":
		return "rune"
	case "string":
		return "string"
		// TODO data/time
	case "date", "dateTime", " dateTime.tz", "time", "time.tz":
		return "string"
	case "boolean":
		return "bool"
		// TODO
	// case "bin.base64", "bin.hex":
	// 	return "string"
	case "uri":
		return "*url.URL"
	case "uuid":
		return "string"
	default:
		return ""
	}
}

type Argument struct {
	XMLName              xml.Name `xml:"argument"`
	Name                 string   `xml:"name"`
	Direction            string   `xml:"direction"`
	RelatedStateVariable string   `xml:"relatedStateVariable"`
}

type Action struct {
	XMLName   xml.Name   `xml:"action"`
	Name      string     `xml:"name"`
	Arguments []Argument `xml:"argumentList>argument"`
}

type SpecVersion struct {
	XMLName xml.Name `xml:"specVersion"`
	Major   int      `xml:"major"`
	Minor   int      `xml:"minor"`
}

type Scpd struct {
	XMLName        xml.Name        `xml:"scpd"`
	Xmlns          string          `xml:"type,attr"`
	SpecVersion    SpecVersion     `xml:"specVersion"`
	StateVariables []StateVariable `xml:"serviceStateTable>stateVariable"`
	Actions        []Action        `xml:"actionList>action"`
}

func (s *Scpd) GetStateVariable(name string) *StateVariable {
	for _, sv := range s.StateVariables {
		if sv.Name == name {
			return &sv
		}
	}
	return nil
}

func MakeServiceApi(ServiceName, serviceControlEndpoint, serviceEventEndpoint string, scdp []byte) ([]byte, error) {
	var s Scpd
	err := xml.Unmarshal(scdp, &s)
	if err != nil {
		return nil, err
	}

	state := bytes.NewBufferString("")

	for _, sv := range s.StateVariables {
		if sv.SendEvents != "yes" {
			continue
		}
		fmt.Fprintf(state, "type %s %s\n", sv.Name, sv.GoDataType())
	}

	otherstate := bytes.NewBufferString("")

	for _, sv := range s.StateVariables {
		if sv.SendEvents != "yes" {
			continue
		}
		fmt.Fprintf(otherstate, "%s *%s\n", sv.Name, sv.Name)
	}

	buf := bytes.NewBufferString("")

	// Header
	w := `
// Code generated by makeservice. DO NOT EDIT.

// Package %s is a generated %s package.
package %s

import (
	"bytes"
	"encoding/xml"
	"errors"
	"io/ioutil"
	"net/http"
	"net/url"
)

const (
	ServiceURN     = "urn:schemas-upnp-org:service:%s:1"
	EncodingSchema = "http://schemas.xmlsoap.org/soap/encoding/"
	EnvelopeSchema = "http://schemas.xmlsoap.org/soap/envelope/"
)

type ServiceOption func(*Service)

func WithClient(c *http.Client) ServiceOption {
	return func(s *Service) {
		s.client = c
	}
}

func WithLocation(u *url.URL) ServiceOption {
	return func(s *Service) {
		s.location = u
	}
}

%s

type Service struct {
	controlEndpoint *url.URL
	eventEndpoint   *url.URL

	%s

	location        *url.URL
	client          *http.Client
}

func NewService(opts ...ServiceOption) *Service {
	s := &Service{}

	c, err := url.Parse("%s")
	if nil != err {
		panic(err)
	}
	e, err := url.Parse("%s")
	if nil != err {
		panic(err)
	}

	for _, opt := range opts {
		opt(s)
	}

	if s.client == nil {
		panic("no client location")
	}
	if s.location == nil {
		panic("empty location")
	}

	s.controlEndpoint = s.location.ResolveReference(c)
	s.eventEndpoint = s.location.ResolveReference(e)

	return s
}

func (s *Service) ControlEndpoint() *url.URL{
	return s.controlEndpoint
}

func (s *Service) EventEndpoint() *url.URL{
	return s.eventEndpoint
}

func (s *Service) Location() *url.URL{
	return s.location
}

func (s *Service) Client() *http.Client {
	return s.client
}
	`
	fmt.Fprintf(buf, w,
		strings.ToLower(ServiceName),
		ServiceName,
		strings.ToLower(ServiceName),
		ServiceName,

		state,
		otherstate,
		serviceControlEndpoint,
		serviceEventEndpoint,
	)

	// Martial structs
	fmt.Fprintf(buf, "// internal use only\n")
	fmt.Fprintf(buf, "type envelope struct {\n")
	fmt.Fprintf(buf, "XMLName xml.Name `xml:\"s:Envelope\"`\n")
	fmt.Fprintf(buf, "Xmlns string `xml:\"xmlns:s,attr\"`\n")
	fmt.Fprintf(buf, "EncodingStyle string `xml:\"s:encodingStyle,attr\"`\n")
	fmt.Fprintf(buf, "Body body `xml:\"s:Body\"`\n")
	fmt.Fprintf(buf, "}\n")

	fmt.Fprintf(buf, "// internal use only\n")
	fmt.Fprintf(buf, "type body struct {\n")
	fmt.Fprint(buf, "XMLName xml.Name `xml:\"s:Body\"`\n")
	for _, action := range s.Actions {
		fmt.Fprintf(buf, "%s *%sArgs `xml:\"u:%s,omitempty\"`\n", action.Name, action.Name, action.Name)
	}
	fmt.Fprint(buf, "}\n")

	// Unmartial structs
	fmt.Fprintf(buf, "// internal use only\n")
	fmt.Fprintf(buf, "type envelopeResponse struct {\n")
	fmt.Fprintf(buf, "XMLName xml.Name `xml:\"Envelope\"`\n")
	fmt.Fprintf(buf, "Xmlns string `xml:\"xmlns:s,attr\"`\n")
	fmt.Fprintf(buf, "EncodingStyle string `xml:\"encodingStyle,attr\"`\n")
	fmt.Fprintf(buf, "Body bodyResponse `xml:\"Body\"`\n")
	fmt.Fprintf(buf, "}\n")

	fmt.Fprintf(buf, "// internal use only\n")
	fmt.Fprintf(buf, "type bodyResponse struct {\n")
	fmt.Fprint(buf, "XMLName xml.Name `xml:\"Body\"`\n")
	for _, action := range s.Actions {
		fmt.Fprintf(buf, "%s *%sResponse `xml:\"%sResponse,omitempty\"`\n", action.Name, action.Name, action.Name)
	}
	fmt.Fprintf(buf, "}\n")

	// exec function
	w = `
func (s *Service) exec(actionName string, envelope *envelope) (*envelopeResponse, error) {
	postBody, err := xml.Marshal(envelope)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", s.controlEndpoint.String(), bytes.NewBuffer(postBody))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "text/xml; charset=\"utf-8\"")
	req.Header.Set("SOAPAction", ServiceURN+"#"+actionName)
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	responseBody, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}
	var envelopeResponse envelopeResponse
	err = xml.Unmarshal(responseBody, &envelopeResponse)
	if err != nil {
		return nil, err
	}
	return &envelopeResponse, nil
}
	`
	fmt.Fprintf(buf, w)

	for _, action := range s.Actions {
		var inArguments, outArguments []Argument
		for _, argument := range action.Arguments {
			switch argument.Direction {
			case "in":
				inArguments = append(inArguments, argument)
			case "out":
				outArguments = append(outArguments, argument)
			default:
				return []byte{}, errors.New("unexpected action direction")
			}
		}

		fmt.Fprintf(buf, "type %sArgs struct {\n", action.Name)
		fmt.Fprintf(buf, "Xmlns string `xml:\"xmlns:u,attr\"`\n")
		for _, argument := range inArguments {
			sv := s.GetStateVariable(argument.RelatedStateVariable)
			if sv == nil {
				return []byte{}, fmt.Errorf("unexpected state variable %s", argument.RelatedStateVariable)
			}
			if sv.AllowedValueRange != nil {
				fmt.Fprintf(buf, "// Allowed Range: %s -> %s step: %s\n", sv.AllowedValueRange.Minimum, sv.AllowedValueRange.Maximum, sv.AllowedValueRange.Step)
			}
			for _, allowedValue := range sv.AllowedValues {
				fmt.Fprintf(buf, "// Allowed Value: %s\n", allowedValue)
			}
			fmt.Fprintf(buf, "%s %s `xml:\"%s\"`\n", argument.Name, sv.GoDataType(), argument.Name)
		}
		fmt.Fprintf(buf, "}\n")

		fmt.Fprintf(buf, "type %sResponse struct {\n", action.Name)
		for _, argument := range outArguments {
			sv := s.GetStateVariable(argument.RelatedStateVariable)
			if sv == nil {
				return []byte{}, fmt.Errorf("unexpected state variable %s", argument.RelatedStateVariable)
			}
			fmt.Fprintf(buf, "%s %s\t`xml:\"%s\"`\n", argument.Name, sv.GoDataType(), argument.Name)
		}
		fmt.Fprintf(buf, "}\n")

		// TODO Validate, inputs
		fmt.Fprintf(buf, "func (s *Service) %s(args *%sArgs) (*%sResponse, error) {\n", action.Name, action.Name, action.Name)
		fmt.Fprintf(buf, "args.Xmlns = ServiceURN\n")
		fmt.Fprintf(buf, "r, err := s.exec(\"%s\", \n&envelope{\n", action.Name)
		fmt.Fprintf(buf, "EncodingStyle: EncodingSchema,\n")
		fmt.Fprintf(buf, "Xmlns: EnvelopeSchema,\n")
		fmt.Fprintf(buf, "Body: body{%s: args},\n", action.Name)
		fmt.Fprintf(buf, "})\n")
		fmt.Fprintf(buf, "if err != nil { return nil, err }\n")
		fmt.Fprintf(buf, "if r.Body.%s == nil { return nil, errors.New(`unexpected response from service calling %s.%s()`) }\n",
			action.Name, strings.ToLower(ServiceName), action.Name)
		fmt.Fprintf(buf, "\nreturn r.Body.%s, nil }\n", action.Name)
	}

	// Events
	fmt.Fprintf(buf, "type UpnpEvent struct {\nXMLName xml.Name `xml:\"propertyset\"`\nXMLNameSpace string `xml:\"xmlns:e,attr\"`\nProperties []Property `xml:\"property\"`\n}\n")
	fmt.Fprintf(buf, "type Property struct {\nXMLName xml.Name `xml:\"property\"`\n")
	for _, sv := range s.StateVariables {
		if sv.SendEvents != "yes" {
			continue
		}
		fmt.Fprintf(buf, "%s *%s `xml:\"%s\"`\n", sv.Name, sv.Name, sv.Name)
	}

	fmt.Fprint(buf, "}\n")
	fmt.Fprintf(buf, `func (zp *Service) ParseEvent(body []byte) []interface{} {
	var evt UpnpEvent
	var events []interface{}
	err := xml.Unmarshal(body, &evt)
	if err != nil {
		return events
	}
	for _, prop := range evt.Properties {
	_ = prop
	switch {
`)
	for _, sv := range s.StateVariables {
		if sv.SendEvents != "yes" {
			continue
		}
		// fmt.Fprintf(buf, "case prop.%s != nil:\n zp.EventCallback(*prop.%s)\n", sv.Name, sv.Name)
		fmt.Fprintf(buf, "case prop.%s != nil:\n", sv.Name)
		fmt.Fprintf(buf, "zp.%s = prop.%s\n", sv.Name, sv.Name)
		fmt.Fprintf(buf, "events = append(events, *prop.%s)\n", sv.Name)
	}
	fmt.Fprintf(buf, "}\n}\nreturn events\n}")

	return buf.Bytes(), nil
}

func main() {
	serviceName := os.Args[1]
	serviceEndpoint := os.Args[2]
	controlEndpoint := os.Args[3]
	serviceXml := os.Args[4]
	body, err := ioutil.ReadFile(serviceXml)
	if err != nil {
		fmt.Printf("err: %v\n", err)
		return
	}
	dotgo, err := MakeServiceApi(serviceName, serviceEndpoint, controlEndpoint, body)
	if err != nil {
		fmt.Printf("err: %v\n", err)
		return
	}
	fmt.Printf("%s\n", string(dotgo))
}
