// Code generated by makeservice. DO NOT EDIT.

// Package zonegrouptopology is a generated ZoneGroupTopology package.
package zonegrouptopology

import (
	"bytes"
	"encoding/xml"
	"errors"
	"io/ioutil"
	"net/http"
	"net/url"
)

const (
	ServiceURN     = "urn:schemas-upnp-org:service:ZoneGroupTopology:1"
	EncodingSchema = "http://schemas.xmlsoap.org/soap/encoding/"
	EnvelopeSchema = "http://schemas.xmlsoap.org/soap/envelope/"
)

type ServiceOption func(*Service)

func WithClient(c *http.Client) ServiceOption {
	return func(s *Service) {
		s.client = c
	}
}

func WithLocation(u *url.URL) ServiceOption {
	return func(s *Service) {
		s.location = u
	}
}

type AvailableSoftwareUpdate string
type ZoneGroupState string
type ThirdPartyMediaServersX string
type AlarmRunSequence string
type MuseHouseholdId string
type ZoneGroupName string
type ZoneGroupID string
type ZonePlayerUUIDsInGroup string
type AreasUpdateID string
type SourceAreasUpdateID string
type NetsettingsUpdateID string

type Service struct {
	controlEndpoint *url.URL
	eventEndpoint   *url.URL

	AvailableSoftwareUpdate *AvailableSoftwareUpdate
	ZoneGroupState          *ZoneGroupState
	ThirdPartyMediaServersX *ThirdPartyMediaServersX
	AlarmRunSequence        *AlarmRunSequence
	MuseHouseholdId         *MuseHouseholdId
	ZoneGroupName           *ZoneGroupName
	ZoneGroupID             *ZoneGroupID
	ZonePlayerUUIDsInGroup  *ZonePlayerUUIDsInGroup
	AreasUpdateID           *AreasUpdateID
	SourceAreasUpdateID     *SourceAreasUpdateID
	NetsettingsUpdateID     *NetsettingsUpdateID

	location *url.URL
	client   *http.Client
}

func NewService(opts ...ServiceOption) *Service {
	s := &Service{}

	c, err := url.Parse("/ZoneGroupTopology/Control")
	if nil != err {
		panic(err)
	}
	e, err := url.Parse("/ZoneGroupTopology/Event")
	if nil != err {
		panic(err)
	}

	for _, opt := range opts {
		opt(s)
	}

	if s.client == nil {
		panic("no client location")
	}
	if s.location == nil {
		panic("empty location")
	}

	s.controlEndpoint = s.location.ResolveReference(c)
	s.eventEndpoint = s.location.ResolveReference(e)

	return s
}

func (s *Service) ControlEndpoint() *url.URL {
	return s.controlEndpoint
}

func (s *Service) EventEndpoint() *url.URL {
	return s.eventEndpoint
}

func (s *Service) Location() *url.URL {
	return s.location
}

func (s *Service) Client() *http.Client {
	return s.client
}

// internal use only
type envelope struct {
	XMLName       xml.Name `xml:"s:Envelope"`
	Xmlns         string   `xml:"xmlns:s,attr"`
	EncodingStyle string   `xml:"s:encodingStyle,attr"`
	Body          body     `xml:"s:Body"`
}

// internal use only
type body struct {
	XMLName                   xml.Name                       `xml:"s:Body"`
	CheckForUpdate            *CheckForUpdateArgs            `xml:"u:CheckForUpdate,omitempty"`
	BeginSoftwareUpdate       *BeginSoftwareUpdateArgs       `xml:"u:BeginSoftwareUpdate,omitempty"`
	ReportUnresponsiveDevice  *ReportUnresponsiveDeviceArgs  `xml:"u:ReportUnresponsiveDevice,omitempty"`
	ReportAlarmStartedRunning *ReportAlarmStartedRunningArgs `xml:"u:ReportAlarmStartedRunning,omitempty"`
	SubmitDiagnostics         *SubmitDiagnosticsArgs         `xml:"u:SubmitDiagnostics,omitempty"`
	RegisterMobileDevice      *RegisterMobileDeviceArgs      `xml:"u:RegisterMobileDevice,omitempty"`
	GetZoneGroupAttributes    *GetZoneGroupAttributesArgs    `xml:"u:GetZoneGroupAttributes,omitempty"`
	GetZoneGroupState         *GetZoneGroupStateArgs         `xml:"u:GetZoneGroupState,omitempty"`
}

// internal use only
type envelopeResponse struct {
	XMLName       xml.Name     `xml:"Envelope"`
	Xmlns         string       `xml:"xmlns:s,attr"`
	EncodingStyle string       `xml:"encodingStyle,attr"`
	Body          bodyResponse `xml:"Body"`
}

// internal use only
type bodyResponse struct {
	XMLName                   xml.Name                           `xml:"Body"`
	CheckForUpdate            *CheckForUpdateResponse            `xml:"CheckForUpdateResponse,omitempty"`
	BeginSoftwareUpdate       *BeginSoftwareUpdateResponse       `xml:"BeginSoftwareUpdateResponse,omitempty"`
	ReportUnresponsiveDevice  *ReportUnresponsiveDeviceResponse  `xml:"ReportUnresponsiveDeviceResponse,omitempty"`
	ReportAlarmStartedRunning *ReportAlarmStartedRunningResponse `xml:"ReportAlarmStartedRunningResponse,omitempty"`
	SubmitDiagnostics         *SubmitDiagnosticsResponse         `xml:"SubmitDiagnosticsResponse,omitempty"`
	RegisterMobileDevice      *RegisterMobileDeviceResponse      `xml:"RegisterMobileDeviceResponse,omitempty"`
	GetZoneGroupAttributes    *GetZoneGroupAttributesResponse    `xml:"GetZoneGroupAttributesResponse,omitempty"`
	GetZoneGroupState         *GetZoneGroupStateResponse         `xml:"GetZoneGroupStateResponse,omitempty"`
}

func (s *Service) exec(actionName string, envelope *envelope) (*envelopeResponse, error) {
	postBody, err := xml.Marshal(envelope)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", s.controlEndpoint.String(), bytes.NewBuffer(postBody))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "text/xml; charset=\"utf-8\"")
	req.Header.Set("SOAPAction", ServiceURN+"#"+actionName)
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	responseBody, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}
	var envelopeResponse envelopeResponse
	err = xml.Unmarshal(responseBody, &envelopeResponse)
	if err != nil {
		return nil, err
	}
	return &envelopeResponse, nil
}

type CheckForUpdateArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
	// Allowed Value: All
	// Allowed Value: Software
	UpdateType string `xml:"UpdateType"`
	CachedOnly bool   `xml:"CachedOnly"`
	Version    string `xml:"Version"`
}
type CheckForUpdateResponse struct {
	UpdateItem string `xml:"UpdateItem"`
}

func (s *Service) CheckForUpdate(args *CheckForUpdateArgs) (*CheckForUpdateResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("CheckForUpdate",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{CheckForUpdate: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.CheckForUpdate == nil {
		return nil, errors.New(`unexpected response from service calling zonegrouptopology.CheckForUpdate()`)
	}

	return r.Body.CheckForUpdate, nil
}

type BeginSoftwareUpdateArgs struct {
	Xmlns        string `xml:"xmlns:u,attr"`
	UpdateURL    string `xml:"UpdateURL"`
	Flags        uint32 `xml:"Flags"`
	ExtraOptions string `xml:"ExtraOptions"`
}
type BeginSoftwareUpdateResponse struct {
}

func (s *Service) BeginSoftwareUpdate(args *BeginSoftwareUpdateArgs) (*BeginSoftwareUpdateResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("BeginSoftwareUpdate",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{BeginSoftwareUpdate: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.BeginSoftwareUpdate == nil {
		return nil, errors.New(`unexpected response from service calling zonegrouptopology.BeginSoftwareUpdate()`)
	}

	return r.Body.BeginSoftwareUpdate, nil
}

type ReportUnresponsiveDeviceArgs struct {
	Xmlns      string `xml:"xmlns:u,attr"`
	DeviceUUID string `xml:"DeviceUUID"`
	// Allowed Value: Remove
	// Allowed Value: TopologyMonitorProbe
	// Allowed Value: VerifyThenRemoveSystemwide
	DesiredAction string `xml:"DesiredAction"`
}
type ReportUnresponsiveDeviceResponse struct {
}

func (s *Service) ReportUnresponsiveDevice(args *ReportUnresponsiveDeviceArgs) (*ReportUnresponsiveDeviceResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("ReportUnresponsiveDevice",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{ReportUnresponsiveDevice: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.ReportUnresponsiveDevice == nil {
		return nil, errors.New(`unexpected response from service calling zonegrouptopology.ReportUnresponsiveDevice()`)
	}

	return r.Body.ReportUnresponsiveDevice, nil
}

type ReportAlarmStartedRunningArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}
type ReportAlarmStartedRunningResponse struct {
}

func (s *Service) ReportAlarmStartedRunning(args *ReportAlarmStartedRunningArgs) (*ReportAlarmStartedRunningResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("ReportAlarmStartedRunning",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{ReportAlarmStartedRunning: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.ReportAlarmStartedRunning == nil {
		return nil, errors.New(`unexpected response from service calling zonegrouptopology.ReportAlarmStartedRunning()`)
	}

	return r.Body.ReportAlarmStartedRunning, nil
}

type SubmitDiagnosticsArgs struct {
	Xmlns              string `xml:"xmlns:u,attr"`
	IncludeControllers bool   `xml:"IncludeControllers"`
	Type               string `xml:"Type"`
}
type SubmitDiagnosticsResponse struct {
	DiagnosticID uint32 `xml:"DiagnosticID"`
}

func (s *Service) SubmitDiagnostics(args *SubmitDiagnosticsArgs) (*SubmitDiagnosticsResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("SubmitDiagnostics",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{SubmitDiagnostics: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.SubmitDiagnostics == nil {
		return nil, errors.New(`unexpected response from service calling zonegrouptopology.SubmitDiagnostics()`)
	}

	return r.Body.SubmitDiagnostics, nil
}

type RegisterMobileDeviceArgs struct {
	Xmlns            string `xml:"xmlns:u,attr"`
	MobileDeviceName string `xml:"MobileDeviceName"`
	MobileDeviceUDN  string `xml:"MobileDeviceUDN"`
	MobileIPAndPort  string `xml:"MobileIPAndPort"`
}
type RegisterMobileDeviceResponse struct {
}

func (s *Service) RegisterMobileDevice(args *RegisterMobileDeviceArgs) (*RegisterMobileDeviceResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("RegisterMobileDevice",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{RegisterMobileDevice: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.RegisterMobileDevice == nil {
		return nil, errors.New(`unexpected response from service calling zonegrouptopology.RegisterMobileDevice()`)
	}

	return r.Body.RegisterMobileDevice, nil
}

type GetZoneGroupAttributesArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}
type GetZoneGroupAttributesResponse struct {
	CurrentZoneGroupName          string `xml:"CurrentZoneGroupName"`
	CurrentZoneGroupID            string `xml:"CurrentZoneGroupID"`
	CurrentZonePlayerUUIDsInGroup string `xml:"CurrentZonePlayerUUIDsInGroup"`
	CurrentMuseHouseholdId        string `xml:"CurrentMuseHouseholdId"`
}

func (s *Service) GetZoneGroupAttributes(args *GetZoneGroupAttributesArgs) (*GetZoneGroupAttributesResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetZoneGroupAttributes",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetZoneGroupAttributes: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetZoneGroupAttributes == nil {
		return nil, errors.New(`unexpected response from service calling zonegrouptopology.GetZoneGroupAttributes()`)
	}

	return r.Body.GetZoneGroupAttributes, nil
}

type GetZoneGroupStateArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}
type GetZoneGroupStateResponse struct {
	ZoneGroupState string `xml:"ZoneGroupState"`
}

func (s *Service) GetZoneGroupState(args *GetZoneGroupStateArgs) (*GetZoneGroupStateResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetZoneGroupState",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetZoneGroupState: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetZoneGroupState == nil {
		return nil, errors.New(`unexpected response from service calling zonegrouptopology.GetZoneGroupState()`)
	}

	return r.Body.GetZoneGroupState, nil
}

type UpnpEvent struct {
	XMLName      xml.Name   `xml:"propertyset"`
	XMLNameSpace string     `xml:"xmlns:e,attr"`
	Properties   []Property `xml:"property"`
}
type Property struct {
	XMLName                 xml.Name                 `xml:"property"`
	AvailableSoftwareUpdate *AvailableSoftwareUpdate `xml:"AvailableSoftwareUpdate"`
	ZoneGroupState          *ZoneGroupState          `xml:"ZoneGroupState"`
	ThirdPartyMediaServersX *ThirdPartyMediaServersX `xml:"ThirdPartyMediaServersX"`
	AlarmRunSequence        *AlarmRunSequence        `xml:"AlarmRunSequence"`
	MuseHouseholdId         *MuseHouseholdId         `xml:"MuseHouseholdId"`
	ZoneGroupName           *ZoneGroupName           `xml:"ZoneGroupName"`
	ZoneGroupID             *ZoneGroupID             `xml:"ZoneGroupID"`
	ZonePlayerUUIDsInGroup  *ZonePlayerUUIDsInGroup  `xml:"ZonePlayerUUIDsInGroup"`
	AreasUpdateID           *AreasUpdateID           `xml:"AreasUpdateID"`
	SourceAreasUpdateID     *SourceAreasUpdateID     `xml:"SourceAreasUpdateID"`
	NetsettingsUpdateID     *NetsettingsUpdateID     `xml:"NetsettingsUpdateID"`
}

func (zp *Service) ParseEvent(body []byte) []interface{} {
	var evt UpnpEvent
	var events []interface{}
	err := xml.Unmarshal(body, &evt)
	if err != nil {
		return events
	}
	for _, prop := range evt.Properties {
		_ = prop
		switch {
		case prop.AvailableSoftwareUpdate != nil:
			zp.AvailableSoftwareUpdate = prop.AvailableSoftwareUpdate
			events = append(events, *prop.AvailableSoftwareUpdate)
		case prop.ZoneGroupState != nil:
			zp.ZoneGroupState = prop.ZoneGroupState
			events = append(events, *prop.ZoneGroupState)
		case prop.ThirdPartyMediaServersX != nil:
			zp.ThirdPartyMediaServersX = prop.ThirdPartyMediaServersX
			events = append(events, *prop.ThirdPartyMediaServersX)
		case prop.AlarmRunSequence != nil:
			zp.AlarmRunSequence = prop.AlarmRunSequence
			events = append(events, *prop.AlarmRunSequence)
		case prop.MuseHouseholdId != nil:
			zp.MuseHouseholdId = prop.MuseHouseholdId
			events = append(events, *prop.MuseHouseholdId)
		case prop.ZoneGroupName != nil:
			zp.ZoneGroupName = prop.ZoneGroupName
			events = append(events, *prop.ZoneGroupName)
		case prop.ZoneGroupID != nil:
			zp.ZoneGroupID = prop.ZoneGroupID
			events = append(events, *prop.ZoneGroupID)
		case prop.ZonePlayerUUIDsInGroup != nil:
			zp.ZonePlayerUUIDsInGroup = prop.ZonePlayerUUIDsInGroup
			events = append(events, *prop.ZonePlayerUUIDsInGroup)
		case prop.AreasUpdateID != nil:
			zp.AreasUpdateID = prop.AreasUpdateID
			events = append(events, *prop.AreasUpdateID)
		case prop.SourceAreasUpdateID != nil:
			zp.SourceAreasUpdateID = prop.SourceAreasUpdateID
			events = append(events, *prop.SourceAreasUpdateID)
		case prop.NetsettingsUpdateID != nil:
			zp.NetsettingsUpdateID = prop.NetsettingsUpdateID
			events = append(events, *prop.NetsettingsUpdateID)
		}
	}
	return events
}
