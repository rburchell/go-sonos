// Code generated by makeservice. DO NOT EDIT.

// Package contentdirectory is a generated ContentDirectory package.
package contentdirectory

import (
	"bytes"
	"encoding/xml"
	"errors"
	"io/ioutil"
	"net/http"
	"net/url"
)

const (
	ServiceURN     = "urn:schemas-upnp-org:service:ContentDirectory:1"
	EncodingSchema = "http://schemas.xmlsoap.org/soap/encoding/"
	EnvelopeSchema = "http://schemas.xmlsoap.org/soap/envelope/"
)

type ServiceOption func(*Service)

func WithClient(c *http.Client) ServiceOption {
	return func(s *Service) {
		s.client = c
	}
}

func WithLocation(u *url.URL) ServiceOption {
	return func(s *Service) {
		s.location = u
	}
}

type SystemUpdateID uint32
type ContainerUpdateIDs string
type ShareIndexInProgress bool
type ShareIndexLastError string
type UserRadioUpdateID string
type SavedQueuesUpdateID string
type ShareListUpdateID string
type RecentlyPlayedUpdateID string
type Browseable bool
type RadioFavoritesUpdateID uint32
type RadioLocationUpdateID uint32
type FavoritesUpdateID string
type FavoritePresetsUpdateID string

type Service struct {
	controlEndpoint *url.URL
	eventEndpoint   *url.URL

	SystemUpdateID          *SystemUpdateID
	ContainerUpdateIDs      *ContainerUpdateIDs
	ShareIndexInProgress    *ShareIndexInProgress
	ShareIndexLastError     *ShareIndexLastError
	UserRadioUpdateID       *UserRadioUpdateID
	SavedQueuesUpdateID     *SavedQueuesUpdateID
	ShareListUpdateID       *ShareListUpdateID
	RecentlyPlayedUpdateID  *RecentlyPlayedUpdateID
	Browseable              *Browseable
	RadioFavoritesUpdateID  *RadioFavoritesUpdateID
	RadioLocationUpdateID   *RadioLocationUpdateID
	FavoritesUpdateID       *FavoritesUpdateID
	FavoritePresetsUpdateID *FavoritePresetsUpdateID

	location *url.URL
	client   *http.Client
}

func NewService(opts ...ServiceOption) *Service {
	s := &Service{}

	c, err := url.Parse("/MediaServer/ContentDirectory/Control")
	if nil != err {
		panic(err)
	}
	e, err := url.Parse("/MediaServer/ContentDirectory/Event")
	if nil != err {
		panic(err)
	}

	for _, opt := range opts {
		opt(s)
	}

	if s.client == nil {
		panic("no client location")
	}
	if s.location == nil {
		panic("empty location")
	}

	s.controlEndpoint = s.location.ResolveReference(c)
	s.eventEndpoint = s.location.ResolveReference(e)

	return s
}

func (s *Service) ControlEndpoint() *url.URL {
	return s.controlEndpoint
}

func (s *Service) EventEndpoint() *url.URL {
	return s.eventEndpoint
}

func (s *Service) Location() *url.URL {
	return s.location
}

func (s *Service) Client() *http.Client {
	return s.client
}

// internal use only
type envelope struct {
	XMLName       xml.Name `xml:"s:Envelope"`
	Xmlns         string   `xml:"xmlns:s,attr"`
	EncodingStyle string   `xml:"s:encodingStyle,attr"`
	Body          body     `xml:"s:Body"`
}

// internal use only
type body struct {
	XMLName                     xml.Name                         `xml:"s:Body"`
	GetSearchCapabilities       *GetSearchCapabilitiesArgs       `xml:"u:GetSearchCapabilities,omitempty"`
	GetSortCapabilities         *GetSortCapabilitiesArgs         `xml:"u:GetSortCapabilities,omitempty"`
	GetSystemUpdateID           *GetSystemUpdateIDArgs           `xml:"u:GetSystemUpdateID,omitempty"`
	GetAlbumArtistDisplayOption *GetAlbumArtistDisplayOptionArgs `xml:"u:GetAlbumArtistDisplayOption,omitempty"`
	GetLastIndexChange          *GetLastIndexChangeArgs          `xml:"u:GetLastIndexChange,omitempty"`
	Browse                      *BrowseArgs                      `xml:"u:Browse,omitempty"`
	FindPrefix                  *FindPrefixArgs                  `xml:"u:FindPrefix,omitempty"`
	GetAllPrefixLocations       *GetAllPrefixLocationsArgs       `xml:"u:GetAllPrefixLocations,omitempty"`
	CreateObject                *CreateObjectArgs                `xml:"u:CreateObject,omitempty"`
	UpdateObject                *UpdateObjectArgs                `xml:"u:UpdateObject,omitempty"`
	DestroyObject               *DestroyObjectArgs               `xml:"u:DestroyObject,omitempty"`
	RefreshShareIndex           *RefreshShareIndexArgs           `xml:"u:RefreshShareIndex,omitempty"`
	RequestResort               *RequestResortArgs               `xml:"u:RequestResort,omitempty"`
	GetShareIndexInProgress     *GetShareIndexInProgressArgs     `xml:"u:GetShareIndexInProgress,omitempty"`
	GetBrowseable               *GetBrowseableArgs               `xml:"u:GetBrowseable,omitempty"`
	SetBrowseable               *SetBrowseableArgs               `xml:"u:SetBrowseable,omitempty"`
}

// internal use only
type envelopeResponse struct {
	XMLName       xml.Name     `xml:"Envelope"`
	Xmlns         string       `xml:"xmlns:s,attr"`
	EncodingStyle string       `xml:"encodingStyle,attr"`
	Body          bodyResponse `xml:"Body"`
}

// internal use only
type bodyResponse struct {
	XMLName                     xml.Name                             `xml:"Body"`
	GetSearchCapabilities       *GetSearchCapabilitiesResponse       `xml:"GetSearchCapabilitiesResponse,omitempty"`
	GetSortCapabilities         *GetSortCapabilitiesResponse         `xml:"GetSortCapabilitiesResponse,omitempty"`
	GetSystemUpdateID           *GetSystemUpdateIDResponse           `xml:"GetSystemUpdateIDResponse,omitempty"`
	GetAlbumArtistDisplayOption *GetAlbumArtistDisplayOptionResponse `xml:"GetAlbumArtistDisplayOptionResponse,omitempty"`
	GetLastIndexChange          *GetLastIndexChangeResponse          `xml:"GetLastIndexChangeResponse,omitempty"`
	Browse                      *BrowseResponse                      `xml:"BrowseResponse,omitempty"`
	FindPrefix                  *FindPrefixResponse                  `xml:"FindPrefixResponse,omitempty"`
	GetAllPrefixLocations       *GetAllPrefixLocationsResponse       `xml:"GetAllPrefixLocationsResponse,omitempty"`
	CreateObject                *CreateObjectResponse                `xml:"CreateObjectResponse,omitempty"`
	UpdateObject                *UpdateObjectResponse                `xml:"UpdateObjectResponse,omitempty"`
	DestroyObject               *DestroyObjectResponse               `xml:"DestroyObjectResponse,omitempty"`
	RefreshShareIndex           *RefreshShareIndexResponse           `xml:"RefreshShareIndexResponse,omitempty"`
	RequestResort               *RequestResortResponse               `xml:"RequestResortResponse,omitempty"`
	GetShareIndexInProgress     *GetShareIndexInProgressResponse     `xml:"GetShareIndexInProgressResponse,omitempty"`
	GetBrowseable               *GetBrowseableResponse               `xml:"GetBrowseableResponse,omitempty"`
	SetBrowseable               *SetBrowseableResponse               `xml:"SetBrowseableResponse,omitempty"`
}

func (s *Service) exec(actionName string, envelope *envelope) (*envelopeResponse, error) {
	postBody, err := xml.Marshal(envelope)
	if err != nil {
		return nil, err
	}
	req, err := http.NewRequest("POST", s.controlEndpoint.String(), bytes.NewBuffer(postBody))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "text/xml; charset=\"utf-8\"")
	req.Header.Set("SOAPAction", ServiceURN+"#"+actionName)
	res, err := s.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	responseBody, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}
	var envelopeResponse envelopeResponse
	err = xml.Unmarshal(responseBody, &envelopeResponse)
	if err != nil {
		return nil, err
	}
	return &envelopeResponse, nil
}

type GetSearchCapabilitiesArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}
type GetSearchCapabilitiesResponse struct {
	SearchCaps string `xml:"SearchCaps"`
}

func (s *Service) GetSearchCapabilities(args *GetSearchCapabilitiesArgs) (*GetSearchCapabilitiesResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetSearchCapabilities",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetSearchCapabilities: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetSearchCapabilities == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.GetSearchCapabilities()`)
	}

	return r.Body.GetSearchCapabilities, nil
}

type GetSortCapabilitiesArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}
type GetSortCapabilitiesResponse struct {
	SortCaps string `xml:"SortCaps"`
}

func (s *Service) GetSortCapabilities(args *GetSortCapabilitiesArgs) (*GetSortCapabilitiesResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetSortCapabilities",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetSortCapabilities: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetSortCapabilities == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.GetSortCapabilities()`)
	}

	return r.Body.GetSortCapabilities, nil
}

type GetSystemUpdateIDArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}
type GetSystemUpdateIDResponse struct {
	Id uint32 `xml:"Id"`
}

func (s *Service) GetSystemUpdateID(args *GetSystemUpdateIDArgs) (*GetSystemUpdateIDResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetSystemUpdateID",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetSystemUpdateID: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetSystemUpdateID == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.GetSystemUpdateID()`)
	}

	return r.Body.GetSystemUpdateID, nil
}

type GetAlbumArtistDisplayOptionArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}
type GetAlbumArtistDisplayOptionResponse struct {
	AlbumArtistDisplayOption string `xml:"AlbumArtistDisplayOption"`
}

func (s *Service) GetAlbumArtistDisplayOption(args *GetAlbumArtistDisplayOptionArgs) (*GetAlbumArtistDisplayOptionResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetAlbumArtistDisplayOption",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetAlbumArtistDisplayOption: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetAlbumArtistDisplayOption == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.GetAlbumArtistDisplayOption()`)
	}

	return r.Body.GetAlbumArtistDisplayOption, nil
}

type GetLastIndexChangeArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}
type GetLastIndexChangeResponse struct {
	LastIndexChange string `xml:"LastIndexChange"`
}

func (s *Service) GetLastIndexChange(args *GetLastIndexChangeArgs) (*GetLastIndexChangeResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetLastIndexChange",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetLastIndexChange: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetLastIndexChange == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.GetLastIndexChange()`)
	}

	return r.Body.GetLastIndexChange, nil
}

type BrowseArgs struct {
	Xmlns    string `xml:"xmlns:u,attr"`
	ObjectID string `xml:"ObjectID"`
	// Allowed Value: BrowseMetadata
	// Allowed Value: BrowseDirectChildren
	BrowseFlag     string `xml:"BrowseFlag"`
	Filter         string `xml:"Filter"`
	StartingIndex  uint32 `xml:"StartingIndex"`
	RequestedCount uint32 `xml:"RequestedCount"`
	SortCriteria   string `xml:"SortCriteria"`
}
type BrowseResponse struct {
	Result         string `xml:"Result"`
	NumberReturned uint32 `xml:"NumberReturned"`
	TotalMatches   uint32 `xml:"TotalMatches"`
	UpdateID       uint32 `xml:"UpdateID"`
}

func (s *Service) Browse(args *BrowseArgs) (*BrowseResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("Browse",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{Browse: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.Browse == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.Browse()`)
	}

	return r.Body.Browse, nil
}

type FindPrefixArgs struct {
	Xmlns    string `xml:"xmlns:u,attr"`
	ObjectID string `xml:"ObjectID"`
	Prefix   string `xml:"Prefix"`
}
type FindPrefixResponse struct {
	StartingIndex uint32 `xml:"StartingIndex"`
	UpdateID      uint32 `xml:"UpdateID"`
}

func (s *Service) FindPrefix(args *FindPrefixArgs) (*FindPrefixResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("FindPrefix",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{FindPrefix: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.FindPrefix == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.FindPrefix()`)
	}

	return r.Body.FindPrefix, nil
}

type GetAllPrefixLocationsArgs struct {
	Xmlns    string `xml:"xmlns:u,attr"`
	ObjectID string `xml:"ObjectID"`
}
type GetAllPrefixLocationsResponse struct {
	TotalPrefixes     uint32 `xml:"TotalPrefixes"`
	PrefixAndIndexCSV string `xml:"PrefixAndIndexCSV"`
	UpdateID          uint32 `xml:"UpdateID"`
}

func (s *Service) GetAllPrefixLocations(args *GetAllPrefixLocationsArgs) (*GetAllPrefixLocationsResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetAllPrefixLocations",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetAllPrefixLocations: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetAllPrefixLocations == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.GetAllPrefixLocations()`)
	}

	return r.Body.GetAllPrefixLocations, nil
}

type CreateObjectArgs struct {
	Xmlns       string `xml:"xmlns:u,attr"`
	ContainerID string `xml:"ContainerID"`
	Elements    string `xml:"Elements"`
}
type CreateObjectResponse struct {
	ObjectID string `xml:"ObjectID"`
	Result   string `xml:"Result"`
}

func (s *Service) CreateObject(args *CreateObjectArgs) (*CreateObjectResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("CreateObject",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{CreateObject: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.CreateObject == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.CreateObject()`)
	}

	return r.Body.CreateObject, nil
}

type UpdateObjectArgs struct {
	Xmlns           string `xml:"xmlns:u,attr"`
	ObjectID        string `xml:"ObjectID"`
	CurrentTagValue string `xml:"CurrentTagValue"`
	NewTagValue     string `xml:"NewTagValue"`
}
type UpdateObjectResponse struct {
}

func (s *Service) UpdateObject(args *UpdateObjectArgs) (*UpdateObjectResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("UpdateObject",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{UpdateObject: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.UpdateObject == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.UpdateObject()`)
	}

	return r.Body.UpdateObject, nil
}

type DestroyObjectArgs struct {
	Xmlns    string `xml:"xmlns:u,attr"`
	ObjectID string `xml:"ObjectID"`
}
type DestroyObjectResponse struct {
}

func (s *Service) DestroyObject(args *DestroyObjectArgs) (*DestroyObjectResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("DestroyObject",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{DestroyObject: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.DestroyObject == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.DestroyObject()`)
	}

	return r.Body.DestroyObject, nil
}

type RefreshShareIndexArgs struct {
	Xmlns                    string `xml:"xmlns:u,attr"`
	AlbumArtistDisplayOption string `xml:"AlbumArtistDisplayOption"`
}
type RefreshShareIndexResponse struct {
}

func (s *Service) RefreshShareIndex(args *RefreshShareIndexArgs) (*RefreshShareIndexResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("RefreshShareIndex",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{RefreshShareIndex: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.RefreshShareIndex == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.RefreshShareIndex()`)
	}

	return r.Body.RefreshShareIndex, nil
}

type RequestResortArgs struct {
	Xmlns     string `xml:"xmlns:u,attr"`
	SortOrder string `xml:"SortOrder"`
}
type RequestResortResponse struct {
}

func (s *Service) RequestResort(args *RequestResortArgs) (*RequestResortResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("RequestResort",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{RequestResort: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.RequestResort == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.RequestResort()`)
	}

	return r.Body.RequestResort, nil
}

type GetShareIndexInProgressArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}
type GetShareIndexInProgressResponse struct {
	IsIndexing bool `xml:"IsIndexing"`
}

func (s *Service) GetShareIndexInProgress(args *GetShareIndexInProgressArgs) (*GetShareIndexInProgressResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetShareIndexInProgress",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetShareIndexInProgress: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetShareIndexInProgress == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.GetShareIndexInProgress()`)
	}

	return r.Body.GetShareIndexInProgress, nil
}

type GetBrowseableArgs struct {
	Xmlns string `xml:"xmlns:u,attr"`
}
type GetBrowseableResponse struct {
	IsBrowseable bool `xml:"IsBrowseable"`
}

func (s *Service) GetBrowseable(args *GetBrowseableArgs) (*GetBrowseableResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("GetBrowseable",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{GetBrowseable: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.GetBrowseable == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.GetBrowseable()`)
	}

	return r.Body.GetBrowseable, nil
}

type SetBrowseableArgs struct {
	Xmlns      string `xml:"xmlns:u,attr"`
	Browseable bool   `xml:"Browseable"`
}
type SetBrowseableResponse struct {
}

func (s *Service) SetBrowseable(args *SetBrowseableArgs) (*SetBrowseableResponse, error) {
	args.Xmlns = ServiceURN
	r, err := s.exec("SetBrowseable",
		&envelope{
			EncodingStyle: EncodingSchema,
			Xmlns:         EnvelopeSchema,
			Body:          body{SetBrowseable: args},
		})
	if err != nil {
		return nil, err
	}
	if r.Body.SetBrowseable == nil {
		return nil, errors.New(`unexpected response from service calling contentdirectory.SetBrowseable()`)
	}

	return r.Body.SetBrowseable, nil
}

type UpnpEvent struct {
	XMLName      xml.Name   `xml:"propertyset"`
	XMLNameSpace string     `xml:"xmlns:e,attr"`
	Properties   []Property `xml:"property"`
}
type Property struct {
	XMLName                 xml.Name                 `xml:"property"`
	SystemUpdateID          *SystemUpdateID          `xml:"SystemUpdateID"`
	ContainerUpdateIDs      *ContainerUpdateIDs      `xml:"ContainerUpdateIDs"`
	ShareIndexInProgress    *ShareIndexInProgress    `xml:"ShareIndexInProgress"`
	ShareIndexLastError     *ShareIndexLastError     `xml:"ShareIndexLastError"`
	UserRadioUpdateID       *UserRadioUpdateID       `xml:"UserRadioUpdateID"`
	SavedQueuesUpdateID     *SavedQueuesUpdateID     `xml:"SavedQueuesUpdateID"`
	ShareListUpdateID       *ShareListUpdateID       `xml:"ShareListUpdateID"`
	RecentlyPlayedUpdateID  *RecentlyPlayedUpdateID  `xml:"RecentlyPlayedUpdateID"`
	Browseable              *Browseable              `xml:"Browseable"`
	RadioFavoritesUpdateID  *RadioFavoritesUpdateID  `xml:"RadioFavoritesUpdateID"`
	RadioLocationUpdateID   *RadioLocationUpdateID   `xml:"RadioLocationUpdateID"`
	FavoritesUpdateID       *FavoritesUpdateID       `xml:"FavoritesUpdateID"`
	FavoritePresetsUpdateID *FavoritePresetsUpdateID `xml:"FavoritePresetsUpdateID"`
}

func (zp *Service) ParseEvent(body []byte) []interface{} {
	var evt UpnpEvent
	var events []interface{}
	err := xml.Unmarshal(body, &evt)
	if err != nil {
		return events
	}
	for _, prop := range evt.Properties {
		_ = prop
		switch {
		case prop.SystemUpdateID != nil:
			zp.SystemUpdateID = prop.SystemUpdateID
			events = append(events, *prop.SystemUpdateID)
		case prop.ContainerUpdateIDs != nil:
			zp.ContainerUpdateIDs = prop.ContainerUpdateIDs
			events = append(events, *prop.ContainerUpdateIDs)
		case prop.ShareIndexInProgress != nil:
			zp.ShareIndexInProgress = prop.ShareIndexInProgress
			events = append(events, *prop.ShareIndexInProgress)
		case prop.ShareIndexLastError != nil:
			zp.ShareIndexLastError = prop.ShareIndexLastError
			events = append(events, *prop.ShareIndexLastError)
		case prop.UserRadioUpdateID != nil:
			zp.UserRadioUpdateID = prop.UserRadioUpdateID
			events = append(events, *prop.UserRadioUpdateID)
		case prop.SavedQueuesUpdateID != nil:
			zp.SavedQueuesUpdateID = prop.SavedQueuesUpdateID
			events = append(events, *prop.SavedQueuesUpdateID)
		case prop.ShareListUpdateID != nil:
			zp.ShareListUpdateID = prop.ShareListUpdateID
			events = append(events, *prop.ShareListUpdateID)
		case prop.RecentlyPlayedUpdateID != nil:
			zp.RecentlyPlayedUpdateID = prop.RecentlyPlayedUpdateID
			events = append(events, *prop.RecentlyPlayedUpdateID)
		case prop.Browseable != nil:
			zp.Browseable = prop.Browseable
			events = append(events, *prop.Browseable)
		case prop.RadioFavoritesUpdateID != nil:
			zp.RadioFavoritesUpdateID = prop.RadioFavoritesUpdateID
			events = append(events, *prop.RadioFavoritesUpdateID)
		case prop.RadioLocationUpdateID != nil:
			zp.RadioLocationUpdateID = prop.RadioLocationUpdateID
			events = append(events, *prop.RadioLocationUpdateID)
		case prop.FavoritesUpdateID != nil:
			zp.FavoritesUpdateID = prop.FavoritesUpdateID
			events = append(events, *prop.FavoritesUpdateID)
		case prop.FavoritePresetsUpdateID != nil:
			zp.FavoritePresetsUpdateID = prop.FavoritePresetsUpdateID
			events = append(events, *prop.FavoritePresetsUpdateID)
		}
	}
	return events
}
